#coding=utf-8
class Solution:
    # @param {string} s
    # @return {string[]}
    #*************************************************************************************
    #*************************************************************************************
    #-------------这个题就有点编码的意思了，就是用一个方法来把十位的字符串想出一个编码值来------------
    #-----------------------压入set中，判断是否存在，存在加入到加过中---------------------------
    #-------------我自己之前的做法是：ACGT分别等于1234，然后下一位时，这个数左移两位----------------
    #---------使得十位的结果存在一个20位的数中，但是当时做的时候，没来一个新的字符，就需要------------
    #-------重新算一遍这个flag，其实也没必要重新算，只需要上一个数左移两位并上0xFFFFF即可------------
    #-----别人的算法更巧妙，用一个int来表示，每个字符用3位表示，然后每来一个数上一个数左移三位然后并上---
    # ------------------------------0x3FFFFFF然后或上现在这个数------------------------------
    # ---------------------------0x3FFFFFF就是正好30个1，对应10个数--------------------------
    #*************************************************************************************

    #*************************************************************************************
    #-------------------------------------------------------------------------------------
    #---------------------------------还有一点巧妙的是---------------------------------------
    #----------map中，遇到则加一，只把等于1的情况压入res中，避免了res中的重复出现！！！！------------
    #-------------------------------------------------------------------------------------
    #*************************************************************************************
    def findRepeatedDnaSequences(self, s):
        dic = {}
        i = 0
        encode = 0
        res = []
        while i < len(s):
            temp = ord(s[i:i+1])&7
            encode = ((encode<<3) & 0x3FFFFFFF) | temp
            if encode not in dic:
                dic[encode] = 1
            else:
                if dic[encode] == 1:
                    res.append(s[i-9:i+1])
                dic[encode] += 1
            i += 1
        return res
A = Solution()
print A.findRepeatedDnaSequences("AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT")
print hex(0x11),hex(0x11<<4)