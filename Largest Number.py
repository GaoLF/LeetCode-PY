#coding=utf-8
#------------------------------------------------------------------------
# #----------------------------------------------------------------------
#      *****这个题目我刚才在使劲琢磨怎么写他们的比较函数*************************
#      *****重点就是 "95"应该大于"95958" 而应该小于"95956"********************
#      *****一开始我写的方法是通过循环的遍历a[i/len(a)] b[i]，a是短的一个********
#      *****其实根本不用这么复杂，只需要比较a+b 和b+a的大小即可******************
#      *****sorted函数提供cmp参数来写比较大小的函数，另外还有key参数和reverse参数
#      *****把所有的数转化成str，然后排序之后连起来即可*************************
#      一个比较可恶的情况就是全零串"000000"应返回"0",其他的情况返回"10000"都没问题
#------------------------------------------------------------------------
#------------------------------------------------------------------------
class Solution:
    # @param {integer[]} nums
    # @return {string}
    def largestNumber(self, nums):
        vec = [str(i) for i in nums]
        vec = sorted(vec,cmp = self.lessthan)
        res = ''
        for iter in vec:
            res += iter
        if res[0] == '0':
            res = '0'
        return res

    def lessthan(self,x,y):
        if x + y > y + x:
            return -1
        elif x == y:
            return 0
        else:
            return 1





A = Solution()
print A.largestNumber([3, 30, 34, 5, 9,0])
print A.largestNumber([95,9111,9585,9596,99])
print A.largestNumber([0,0,0])
"""
print "123">"122"
print "123">"1224"
print "9">"9868"
print "123">"1224"
"""